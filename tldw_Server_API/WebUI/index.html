<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabbed API Frontend - Two Tier</title>
    <style>
        body { font-family: sans-serif; margin: 0; background-color: #f4f4f4; color: #333; }
        .app-container { display: flex; flex-direction: column; min-height: 100vh; }
        header { background-color: #007bff; color: white; padding: 15px 20px; text-align: center; }

        /* Top Level Tabs */
        .top-tab-container { width: 100%; background-color: #222; }
        .top-tab-buttons { display: flex; justify-content: center; list-style-type: none; margin: 0; padding: 0; }
        .top-tab-buttons button {
            background-color: #444; color: white; border: none; padding: 14px 25px;
            cursor: pointer; transition: background-color 0.3s ease; font-size: 1.1em;
            border-right: 1px solid #333;
        }
        .top-tab-buttons button:last-child { border-right: none; }
        .top-tab-buttons button:hover { background-color: #666; }
        .top-tab-buttons button.active { background-color: #0056b3; /* Darker blue for active top tab */ }

        /* Sub Level Tabs */
        .sub-tab-row { width: 100%; background-color: #333; display: none; /* Hidden by default */ }
        .sub-tab-row.active { display: block; }
        .sub-tab-buttons { display: flex; justify-content: center; list-style-type: none; margin: 0; padding: 0; overflow-x: auto; }
        .sub-tab-buttons button {
            background-color: #555; color: white; border: none; padding: 12px 20px;
            cursor: pointer; transition: background-color 0.3s ease; font-size: 1em;
            border-right: 1px solid #444; white-space: nowrap;
        }
        .sub-tab-buttons button:last-child { border-right: none; }
        .sub-tab-buttons button:hover { background-color: #777; }
        .sub-tab-buttons button.active { background-color: #007bff; }

        .content-container { flex-grow: 1; padding: 20px; max-width: 1100px; margin: 20px auto; width: calc(100% - 40px); }
        .tab-content { display: none; /* Hidden by default */ }
        .tab-content.active { display: block; }

        /* Styles from previous version for endpoint sections */
        .endpoint-section { border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 5px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .endpoint-section h2 { margin-top: 0; color: #007bff; border-bottom: 1px solid #eee; padding-bottom: 10px; font-size: 1.4em; }
        .endpoint-section h3 { margin-top: 15px; color: #555; font-size: 1.1em; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="number"], input[type="password"], textarea, select {
            width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;
            box-sizing: border-box; font-size: 0.95em;
        }
        textarea { min-height: 80px; resize: vertical; }
        button.api-button { /* Differentiate API call buttons from tab buttons */
            background-color: #28a745; color: white; padding: 10px 15px; border: none; border-radius: 4px;
            cursor: pointer; font-size: 1em; transition: background-color 0.3s ease; margin-top: 10px;
        }
        button.api-button:hover { background-color: #218838; }
        pre { background-color: #e9e9e9; padding: 10px; border: 1px solid #ccc; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; }
        .form-group { margin-bottom: 15px; }
        .checkbox-group label { display: inline-block; margin-right: 10px; font-weight: normal;}
        .checkbox-group input[type="checkbox"] { margin-right: 5px; vertical-align: middle; }
        .columns { display: flex; flex-wrap: wrap; gap: 20px; }
        .column { flex: 1; min-width: 300px; }
        small { color: #666; display: block; margin-top: -5px; margin-bottom: 10px;}
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1>API Interaction Page</h1>
        </header>

        <!-- Top Level Tabs -->
        <div class="top-tab-container">
            <div class="top-tab-buttons">
                <button class="top-tab-button" data-toptab="general">General</button>
                <button class="top-tab-button" data-toptab="media">Media</button>
                <button class="top-tab-button" data-toptab="chat">Chat</button>
            </div>
        </div>

        <!-- Sub Level Tab Rows -->
        <div id="general-subtabs" class="sub-tab-row">
            <div class="sub-tab-buttons">
                <button class="sub-tab-button" data-content-id="tabGlobalSettings">Global Settings</button>
                <button class="sub-tab-button" data-content-id="tabDebug" data-load-group="general">Debug</button>
            </div>
        </div>

        <div id="media-subtabs" class="sub-tab-row">
            <div class="sub-tab-buttons">
                <button class="sub-tab-button" data-content-id="tabMediaManagement" data-load-group="media">Media Management</button>
                <button class="sub-tab-button" data-content-id="tabMediaVersioning" data-load-group="media">Media Versioning</button>
                <button class="sub-tab-button" data-content-id="tabMediaIngestionPersistence" data-load-group="media">Media Ingestion (DB)</button>
                <button class="sub-tab-button" data-content-id="tabMediaProcessingNoDB" data-load-group="media">Media Processing (No DB)</button>
                <button class="sub-tab-button" data-content-id="tabWebScraping" data-load-group="media">Web Scraping</button>
            </div>
        </div>

        <div id="chat-subtabs" class="sub-tab-row">
            <div class="sub-tab-buttons">
                <button class="sub-tab-button" data-content-id="tabChatCompletions" data-load-group="chat">Chat Completions</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="content-container" id="main-content-area">
            <!-- Global Settings Tab Content (always present) -->
            <div id="tabGlobalSettings" class="tab-content">
                <div class="endpoint-section">
                    <h2>Global API Configuration</h2>
                    <div class="form-group">
                        <label for="baseUrl">API Base URL:</label>
                        <input type="text" id="baseUrl" value="http://localhost:8000">
                    </div>
                    <div class="form-group">
                        <label for="apiKeyInput">API Key (X-API-KEY for single-user / JWT for multi-user):</label>
                        <input type="text" id="apiKeyInput" value="default-secret-key-for-single-user"><br>
                        <small>For multi-user, paste JWT here. For single-user, use configured X-API-KEY.</small>
                    </div>
                </div>
            </div>
            <!-- Other tab contents will be loaded here by JavaScript -->
        </div> <!-- end content-container -->
    </div> <!-- end app-container -->

    <script>
        const loadedContentGroups = new Set();
        const mainContentArea = document.getElementById('main-content-area');
        let activeTopTabButton = null;
        let activeSubTabButton = null;

        function initTabs() {
            const topTabButtons = document.querySelectorAll('.top-tab-buttons button');
            topTabButtons.forEach(btn => {
                btn.addEventListener('click', () => activateTopTab(btn));
            });

            const subTabButtons = document.querySelectorAll('.sub-tab-buttons button');
            subTabButtons.forEach(btn => {
                btn.addEventListener('click', () => activateSubTab(btn));
            });

            // Activate the first top tab by default
            if (topTabButtons.length > 0) {
                activateTopTab(topTabButtons[0]);
            }
        }

        async function activateTopTab(topTabButtonToActivate) {
            if (activeTopTabButton) {
                activeTopTabButton.classList.remove('active');
            }
            activeTopTabButton = topTabButtonToActivate;
            activeTopTabButton.classList.add('active');

            const topTabName = activeTopTabButton.dataset.toptab;

            // Hide all sub-tab rows
            document.querySelectorAll('.sub-tab-row').forEach(row => row.classList.remove('active'));

            // Show the current top tab's sub-tab row
            const subTabRowToShow = document.getElementById(topTabName + '-subtabs');
            if (subTabRowToShow) {
                subTabRowToShow.classList.add('active');
                // Activate the first sub-tab in this row
                const firstSubTabButton = subTabRowToShow.querySelector('.sub-tab-buttons button');
                if (firstSubTabButton) {
                    activateSubTab(firstSubTabButton);
                }
            } else { // If no sub-tabs, clear content
                 if (activeSubTabButton) {
                    activeSubTabButton.classList.remove('active');
                    activeSubTabButton = null;
                }
                document.querySelectorAll('.tab-content').forEach(tc => {
                    tc.classList.remove('active');
                    tc.style.display = 'none';
                });
            }
        }

        async function activateSubTab(subTabButtonToActivate) {
            const parentSubTabRow = subTabButtonToActivate.closest('.sub-tab-row');
            if (!parentSubTabRow) return;

            // Deactivate other sub-tabs in the same row
            parentSubTabRow.querySelectorAll('.sub-tab-buttons button').forEach(btn => btn.classList.remove('active'));

            activeSubTabButton = subTabButtonToActivate;
            activeSubTabButton.classList.add('active');

            const contentId = activeSubTabButton.dataset.contentId;
            const loadGroup = activeSubTabButton.dataset.loadGroup;

            if (loadGroup && !loadedContentGroups.has(loadGroup)) {
                try {
                    await loadContentGroup(loadGroup);
                    loadedContentGroups.add(loadGroup);
                } catch (error) {
                    console.error(`Failed to load content for group ${loadGroup}:`, error);
                    const errorDisplay = document.getElementById(contentId) || document.createElement('div');
                    if (!document.getElementById(contentId)) {
                        errorDisplay.id = contentId;
                        errorDisplay.classList.add('tab-content');
                        mainContentArea.appendChild(errorDisplay);
                    }
                    errorDisplay.innerHTML = `<p>Error loading content for ${loadGroup}. Please check console.</p>`;
                    // Still try to show it
                }
            }

            // Hide all tab contents
            mainContentArea.querySelectorAll('.tab-content').forEach(tc => {
                tc.classList.remove('active');
                tc.style.display = 'none'; // Ensure it's hidden
            });

            // Show the target tab content
            const contentToShow = document.getElementById(contentId);
            if (contentToShow) {
                contentToShow.classList.add('active');
                contentToShow.style.display = 'block'; // Ensure it's visible
            } else {
                console.warn(`Content ID "${contentId}" not found after attempting to load group "${loadGroup}".`);
                 // Display a placeholder or error if content still not found
                const placeholder = document.createElement('div');
                placeholder.id = contentId; // So it can be potentially found later
                placeholder.classList.add('tab-content', 'active');
                placeholder.style.display = 'block';
                placeholder.innerHTML = `<p>Content for ${contentId} is missing or failed to load.</p>`;

                // Remove any existing placeholder with the same ID before appending
                const existingPlaceholder = mainContentArea.querySelector(`#${contentId}`);
                if (existingPlaceholder) existingPlaceholder.remove();

                mainContentArea.appendChild(placeholder);
            }
        }

        async function loadContentGroup(groupName) {
            const response = await fetch(`tabs/${groupName}_content.html`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} for tabs/${groupName}_content.html`);
            }
            const html = await response.text();
            mainContentArea.insertAdjacentHTML('beforeend', html);
        }

        document.addEventListener('DOMContentLoaded', initTabs);

        // --- API Call Logic (largely unchanged) ---
        async function makeRequest(endpointId, method, pathTemplate, bodyType = 'json', isStream = false) {
            const baseUrl = document.getElementById('baseUrl').value;
            const apiKeyOrTokenValue = document.getElementById('apiKeyInput').value;
            const responseEl = document.getElementById(endpointId + '_response');
            const curlEl = document.getElementById(endpointId + '_curl');

            if (!responseEl || !curlEl) {
                console.error(`Response or cURL element not found for endpointId: ${endpointId}. Tab content might not be loaded or IDs are incorrect.`);
                alert(`Error: UI elements for ${endpointId} are missing. Content might not be loaded correctly.`);
                return;
            }

            responseEl.textContent = 'Loading...';
            curlEl.textContent = 'Generating...';
            // console.log(`--- Request for ${endpointId} ---`);
            // console.log("Method:", method, "Path Template:", pathTemplate, "Body Type:", bodyType, "Is Stream:", isStream);
            // console.log("API Key/Token from input:", apiKeyOrTokenValue);

            let path = pathTemplate;
            const pathParams = {};
            let bodyPayload = null;
            let headers = {};
            const curlHeaderParts = [];
            const curlFormParts = [];

            if (pathTemplate.includes('{')) {
                pathTemplate.match(/{[a-zA-Z0-9_]+}/g)?.forEach(param => {
                    const paramName = param.substring(1, param.length - 1);
                    const inputEl = document.getElementById(endpointId + '_' + paramName);
                    if (inputEl && inputEl.value) {
                        path = path.replace(param, encodeURIComponent(inputEl.value));
                        pathParams[paramName] = inputEl.value;
                    } else if (inputEl) {
                        // console.warn(`Path parameter '${paramName}' for endpoint '${endpointId}' is empty. Using empty string in path.`);
                        path = path.replace(param, "");
                        pathParams[paramName] = "";
                    } else {
                        console.error(`Missing input element for path parameter ${paramName} for endpoint ${endpointId}`);
                        responseEl.textContent = `Error: Missing input for path parameter ${paramName}`;
                        return;
                    }
                });
            }

            let fullUrl = baseUrl + path;
            // console.log("Initial fullUrl (after path param substitution):", fullUrl);

            if (apiKeyOrTokenValue) {
                headers['X-API-KEY'] = apiKeyOrTokenValue;
                curlHeaderParts.push(`-H "X-API-KEY: ${apiKeyOrTokenValue.replace(/"/g, '\\"')}"`);
                // console.log("Set X-API-KEY header:", apiKeyOrTokenValue);
            } else {
                // console.warn("API Key/Token input is empty. No X-API-KEY header will be sent.");
            }

            const queryParamsForUrl = new URLSearchParams();
            const formSection = document.getElementById(endpointId); // Parent section of the endpoint

            if (formSection && (bodyType === 'query' || bodyType === 'json_with_query' || (method === 'GET' && bodyType !== 'none'))) {
                const formElements = formSection.querySelectorAll(`#${endpointId} input, #${endpointId} select, #${endpointId} textarea`); // Scope to current endpoint
                formElements.forEach(el => {
                    // Ensure element ID is correctly prefixed for this endpoint and not a path param or payload field for json_with_query
                    if (el.id && el.id.startsWith(endpointId + '_')) {
                        const key = el.id.replace(endpointId + '_', '');
                        if (pathParams[key]) return;
                        if (bodyType === 'json_with_query' && key === 'payload') return;

                        if (el.type === 'checkbox') {
                            if (el.checked) queryParamsForUrl.append(key, 'true');
                        } else if (el.type === 'file') { /* skip for query */ }
                        else if (el.tagName.toLowerCase() === 'select' && el.multiple) {
                            for (const option of el.selectedOptions) {
                                if (option.value) queryParamsForUrl.append(key, option.value);
                            }
                        } else if (el.value) {
                            queryParamsForUrl.append(key, el.value);
                        }
                    }
                });
            }
            if (queryParamsForUrl.toString()) {
                fullUrl += (fullUrl.includes('?') ? '&' : '?') + queryParamsForUrl.toString();
            }
            // console.log("URL with query params:", fullUrl);


            if (bodyType === 'json' || bodyType === 'json_with_query') {
                const payloadTextEl = document.getElementById(endpointId + '_payload');
                if (payloadTextEl && payloadTextEl.value) {
                    try {
                        bodyPayload = JSON.parse(payloadTextEl.value);
                        headers['Content-Type'] = 'application/json';
                        // console.log("Set Content-Type header: application/json");
                    } catch (e) {
                        responseEl.textContent = 'Error: Invalid JSON payload. ' + e.message;
                        curlEl.textContent = 'Invalid JSON payload.';
                        console.error("JSON parsing error:", e);
                        return;
                    }
                }
            } else if (bodyType === 'form') {
                bodyPayload = new FormData();
                 if (formSection) {
                    const formElements = formSection.querySelectorAll(`#${endpointId} input, #${endpointId} select, #${endpointId} textarea`);
                    formElements.forEach(el => {
                        if (el.id && el.id.startsWith(endpointId + '_')) {
                            const key = el.id.replace(endpointId + '_', '');
                            if (pathParams[key]) return;
                            if (el.type === 'file') {
                                if (el.files.length > 0) {
                                    for (let i = 0; i < el.files.length; i++) {
                                        bodyPayload.append(key, el.files[i], el.files[i].name);
                                        curlFormParts.push(`-F "${key}=@${el.files[i].name.replace(/"/g, '\\"')}"`);
                                    }
                                }
                            } else if (el.type === 'checkbox') {
                                const val = el.checked ? 'true' : 'false'; // Send 'true'/'false' strings for FormData
                                bodyPayload.append(key, val);
                                curlFormParts.push(`-F "${key}=${val}"`);
                            } else if (el.tagName.toLowerCase() === 'textarea' && key === 'urls') {
                                const urls = el.value.split('\n').map(u => u.trim()).filter(u => u);
                                urls.forEach(url => {
                                    bodyPayload.append(key, url);
                                    curlFormParts.push(`-F "${key}=${url.replace(/"/g, '\\"')}"`);
                                });
                            } else if (el.tagName.toLowerCase() === 'select' && el.value === "" && (key === 'chunk_method' || key.endsWith('_chunk_method'))) {
                                 // console.log(`Skipping empty valued select '${key}' for FormData to allow Pydantic default.`);
                                 curlFormParts.push(`# Optional select '${key}' was empty, not sent.`);
                            } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {
                                for (const option of el.selectedOptions) {
                                    if (option.value) {
                                        bodyPayload.append(key, option.value);
                                        curlFormParts.push(`-F "${key}=${option.value.replace(/"/g, '\\"')}"`);
                                    }
                                }
                            } else if (el.value || ( (el.type === 'text' || el.tagName.toLowerCase() === 'textarea' || el.type === 'password') && el.value === '') ) {
                                // Send empty strings if the field exists and is meant to be text, allows clearing values
                                bodyPayload.append(key, el.value);
                                curlFormParts.push(`-F "${key}=${el.value.replace(/"/g, '\\"')}"`);
                            } else {
                                 // console.log(`Skipping form field with no/falsy value: ${key} (value: '${el.value}')`);
                                 if(el.value === "") curlFormParts.push(`# Optional field '${key}' was empty, not sent.`);
                            }
                        }
                    });
                }
            }

            let finalCurlCommandParts = [`curl -X ${method}`];
            finalCurlCommandParts.push(...curlHeaderParts);
            if (isStream && method === 'POST') {
                finalCurlCommandParts.push('-N'); // For streaming with curl
            }

            if ((bodyType === 'json' || bodyType === 'json_with_query') && bodyPayload) {
                if (!headers['Content-Type']) { // Should have been set if bodyPayload is from JSON
                     finalCurlCommandParts.push(`-H "Content-Type: application/json"`);
                }
                const payloadTextEl = document.getElementById(endpointId + '_payload');
                if (payloadTextEl && payloadTextEl.value) {
                    finalCurlCommandParts.push(`-d '${payloadTextEl.value.replace(/'/g, "'\\''")}'`);
                }
            } else if (bodyType === 'form') {
                finalCurlCommandParts.push(...curlFormParts);
            }

            finalCurlCommandParts.push(`"${fullUrl}"`);
            curlEl.textContent = finalCurlCommandParts.join(' \\\n    ');
            // console.log("Final computed URL for fetch:", fullUrl);
            // console.log("Headers for fetch:", JSON.parse(JSON.stringify(headers))); // Clone for logging

            try {
                const fetchOptions = {
                    method: method,
                    headers: new Headers(headers) // Use Headers object
                };

                if (method !== 'GET' && method !== 'HEAD' && bodyPayload) {
                    fetchOptions.body = ((bodyType === 'json' || bodyType === 'json_with_query') && bodyPayload) ? JSON.stringify(bodyPayload) : bodyPayload;
                }
                // console.log("Fetch options being sent:", fetchOptions);

                const res = await fetch(fullUrl, fetchOptions);
                // console.log("Response status:", res.status);
                const contentTypeHeader = res.headers.get("content-type");
                // console.log("Response Content-Type header:", contentTypeHeader);

                if (isStream && res.ok && res.body) {
                    responseEl.textContent = `Status: ${res.status} (Streaming)\n\n`;
                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        const chunk = decoder.decode(value, { stream: true });
                        // console.log("Stream chunk:", chunk);
                        responseEl.textContent += chunk;
                        responseEl.scrollTop = responseEl.scrollHeight;
                    }
                    responseEl.textContent += "\n\n--- Stream ended ---";
                } else if (contentTypeHeader && contentTypeHeader.includes("application/json")) {
                    const responseData = await res.json();
                    responseEl.textContent = `Status: ${res.status}\n\n` + JSON.stringify(responseData, null, 2);
                    if (!res.ok) console.error(`API Error ${res.status} for ${endpointId}:`, responseData);
                    // else console.log(`API Success for ${endpointId}:`, responseData);
                } else {
                    const responseData = await res.text();
                    responseEl.textContent = `Status: ${res.status}\n\n` + responseData;
                    if (!res.ok) console.error(`API Error ${res.status} for ${endpointId}:`, responseData);
                    // else console.log(`API Success for ${endpointId}:`, responseData);
                }

            } catch (error) {
                responseEl.textContent = 'Network Error: ' + error.message;
                console.error(`Fetch/Network error for ${endpointId}:`, error);
            }
        }

        async function handleChatCompletion(endpointId) {
            const payloadTextEl = document.getElementById(endpointId + '_payload');
            let isStream = false;
            if (payloadTextEl && payloadTextEl.value) {
                try {
                    const payload = JSON.parse(payloadTextEl.value);
                    if (payload.stream === true) {
                        isStream = true;
                    }
                } catch (e) {
                    console.warn("Could not parse chat payload to check for stream flag:", e);
                }
            }
            await makeRequest(endpointId, 'POST', '/api/v1/chat/completions', 'json', isStream);
        }
    </script>
</body>
</html>