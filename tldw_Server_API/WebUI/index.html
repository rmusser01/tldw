<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabbed API Frontend - Two Tier</title>
    <style>
        body { font-family: sans-serif; margin: 0; background-color: #f4f4f4; color: #333; }
        .app-container { display: flex; flex-direction: column; min-height: 100vh; }
        header { background-color: #007bff; color: white; padding: 15px 20px; text-align: center; }

        /* Top Level Tabs */
        .top-tab-container { width: 100%; background-color: #222; }
        .top-tab-buttons { display: flex; justify-content: center; list-style-type: none; margin: 0; padding: 0; }
        .top-tab-buttons button {
            background-color: #444; color: white; border: none; padding: 14px 25px;
            cursor: pointer; transition: background-color 0.3s ease; font-size: 1.1em;
            border-right: 1px solid #333;
        }
        .top-tab-buttons button:last-child { border-right: none; }
        .top-tab-buttons button:hover { background-color: #666; }
        .top-tab-buttons button.active { background-color: #0056b3; /* Darker blue for active top tab */ }

        /* Sub Level Tabs */
        .sub-tab-row { width: 100%; background-color: #333; display: none; /* Hidden by default */ }
        .sub-tab-row.active { display: block; }
        .sub-tab-buttons { display: flex; justify-content: center; list-style-type: none; margin: 0; padding: 0; overflow-x: auto; }
        .sub-tab-buttons button {
            background-color: #555; color: white; border: none; padding: 12px 20px;
            cursor: pointer; transition: background-color 0.3s ease; font-size: 1em;
            border-right: 1px solid #444; white-space: nowrap;
        }
        .sub-tab-buttons button:last-child { border-right: none; }
        .sub-tab-buttons button:hover { background-color: #777; }
        .sub-tab-buttons button.active { background-color: #007bff; }

        .content-container { flex-grow: 1; padding: 20px; max-width: 1100px; margin: 20px auto; width: calc(100% - 40px); }
        .tab-content { display: none; /* Hidden by default */ }
        .tab-content.active { display: block; }

        /* Styles for endpoint sections (generic) */
        .endpoint-section { border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 5px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .endpoint-section h2 { margin-top: 0; color: #007bff; border-bottom: 1px solid #eee; padding-bottom: 10px; font-size: 1.4em; }
        .endpoint-section h3 { margin-top: 15px; color: #555; font-size: 1.1em; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="number"], input[type="password"], textarea, select {
            width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;
            box-sizing: border-box; font-size: 0.95em;
        }
        textarea { min-height: 80px; resize: vertical; }
        button.api-button { /* Differentiate API call buttons from tab buttons */
            background-color: #28a745; color: white; padding: 10px 15px; border: none; border-radius: 4px;
            cursor: pointer; font-size: 1em; transition: background-color 0.3s ease; margin-top: 10px;
        }
        button.api-button:hover { background-color: #218838; }
        pre { background-color: #e9e9e9; padding: 10px; border: 1px solid #ccc; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; max-height: 400px; overflow-y: auto;}
        .form-group { margin-bottom: 15px; }
        .checkbox-group label { display: inline-block; margin-right: 10px; font-weight: normal;}
        .checkbox-group input[type="checkbox"] { margin-right: 5px; vertical-align: middle; width: auto; margin-bottom: 0;}
        .columns { display: flex; flex-wrap: wrap; gap: 20px; }
        .column { flex: 1; min-width: 300px; }
        small { color: #666; display: block; margin-top: -5px; margin-bottom: 10px;}

        /* Chat Completions Specific Styles (New) */
        textarea.raw-payload-textarea { min-height: 250px; font-family: monospace; }
        .message-entry {
            border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px;
            background-color: #f9f9f9;
        }
        .message-entry label { font-size: 0.9em; }
        .message-entry select, .message-entry textarea, .message-entry input[type="text"] { margin-bottom: 5px; }
        .remove-message-btn {
            background-color: #dc3545; color: white; border: none; padding: 5px 10px;
            border-radius: 4px; cursor: pointer; font-size: 0.9em; margin-top: 5px;
        }
        .remove-message-btn:hover { background-color: #c82333; }
        .add-message-btn {
            background-color: #28a745; color: white; border: none; padding: 8px 12px;
            border-radius: 4px; cursor: pointer; font-size: 0.9em; margin-bottom: 15px;
        }
        .add-message-btn:hover { background-color: #218838; }
        .optional-params { border-left: 3px solid #007bff; padding-left: 15px; margin-top: 10px; }
        #chatCompletions_formFields .columns .column input[type="text"],
        #chatCompletions_formFields .columns .column input[type="number"],
        #chatCompletions_formFields .columns .column select {
             width: 100%; /* Override generic width for chat form's columns */
        }
        #chatCompletions_formFields .optional-params input[type="text"],
        #chatCompletions_formFields .optional-params input[type="number"],
        #chatCompletions_formFields .optional-params select,
        #chatCompletions_formFields .optional-params textarea {
             width: 100%; /* Override generic width for chat form's optional params */
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1>API Interaction Page</h1>
        </header>

        <!-- Top Level Tabs -->
        <div class="top-tab-container">
            <div class="top-tab-buttons">
                <button class="top-tab-button" data-toptab="general">General</button>
                <button class="top-tab-button" data-toptab="media">Media</button>
                <button class="top-tab-button" data-toptab="chat" id="top-tab-chat">Chat</button>
            </div>
        </div>

        <!-- Sub Level Tab Rows -->
        <div id="general-subtabs" class="sub-tab-row">
            <div class="sub-tab-buttons">
                <button class="sub-tab-button" data-content-id="tabGlobalSettings">Global Settings</button>
                <button class="sub-tab-button" data-content-id="tabDebug" data-load-group="general">Debug</button>
            </div>
        </div>

        <div id="media-subtabs" class="sub-tab-row">
            <div class="sub-tab-buttons">
                <button class="sub-tab-button" data-content-id="tabMediaManagement" data-load-group="media">Media Management</button>
                <!-- Add other media sub-tabs here -->
            </div>
            <div class="sub-tab-buttons">
                <button class="sub-tab-button" data-content-id="tabMediaManagement" data-load-group="media">Media Management</button>
                <!-- Add other media sub-tabs here -->
            </div>
        </div>

        <div id="chat-subtabs" class="sub-tab-row">
            <div class="sub-tab-buttons">
                <button class="sub-tab-button" data-content-id="tabChatCompletions" data-load-group="chat">Chat Completions</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="content-container" id="main-content-area">
            <!-- Global Settings Tab Content (always present) -->
            <div id="tabGlobalSettings" class="tab-content">
                <div class="endpoint-section">
                    <h2>Global API Configuration</h2>
                    <div class="form-group">
                        <label for="baseUrl">API Base URL:</label>
                        <input type="text" id="baseUrl" value="http://localhost:8000">
                    </div>
                    <div class="form-group">
                        <label for="apiKeyInput">API Token (used in 'Token' header):</label>
                        <input type="text" id="apiKeyInput" value="default-secret-key-for-single-user"><br>
                        <small>This will be sent in the 'Token' header for authenticated requests.</small>
                    </div>
                </div>
            </div>
            <!-- Other tab contents will be loaded here by JavaScript -->
        </div> <!-- end content-container -->
    </div> <!-- end app-container -->

    <script>
        const loadedContentGroups = new Set();
        const mainContentArea = document.getElementById('main-content-area');
        let activeTopTabButton = null;
        let activeSubTabButton = null;
        let messageIdCounter = { chatCompletions: 0 }; // For dynamic message IDs

        function initTabs() {
            const topTabButtons = document.querySelectorAll('.top-tab-buttons button');
            topTabButtons.forEach(btn => {
                btn.addEventListener('click', () => activateTopTab(btn));
            });

            const subTabButtons = document.querySelectorAll('.sub-tab-buttons button');
            subTabButtons.forEach(btn => {
                btn.addEventListener('click', () => activateSubTab(btn));
            });

            // Activate the "Chat" top tab and its "Chat Completions" sub-tab by default
            const defaultTopTab = document.getElementById('top-tab-chat');
            if (defaultTopTab) {
                activateTopTab(defaultTopTab);
            } else if (topTabButtons.length > 0) {
                activateTopTab(topTabButtons[0]); // Fallback to first top tab
            }
        }

        async function activateTopTab(topTabButtonToActivate) {
            if (activeTopTabButton) {
                activeTopTabButton.classList.remove('active');
            }
            activeTopTabButton = topTabButtonToActivate;
            activeTopTabButton.classList.add('active');

            const topTabName = activeTopTabButton.dataset.toptab;
            document.querySelectorAll('.sub-tab-row').forEach(row => row.classList.remove('active'));

            const subTabRowToShow = document.getElementById(topTabName + '-subtabs');
            if (subTabRowToShow) {
                subTabRowToShow.classList.add('active');
                const firstSubTabButton = subTabRowToShow.querySelector('.sub-tab-buttons button');
                if (firstSubTabButton) {
                    await activateSubTab(firstSubTabButton); // Make sure content loading completes
                }
            } else {
                if (activeSubTabButton) {
                    activeSubTabButton.classList.remove('active');
                    activeSubTabButton = null;
                }
                mainContentArea.querySelectorAll('.tab-content').forEach(tc => {
                    tc.classList.remove('active');
                    tc.style.display = 'none';
                });
                 // If top tab has no sub-tabs, check if it's 'general' to show 'tabGlobalSettings'
                if (topTabName === 'general') {
                    const globalSettingsContent = document.getElementById('tabGlobalSettings');
                    if (globalSettingsContent) {
                        globalSettingsContent.classList.add('active');
                        globalSettingsContent.style.display = 'block';
                    }
                }
            }
        }

        async function activateSubTab(subTabButtonToActivate) {
            const parentSubTabRow = subTabButtonToActivate.closest('.sub-tab-row');
            if (!parentSubTabRow) return;

            parentSubTabRow.querySelectorAll('.sub-tab-buttons button').forEach(btn => btn.classList.remove('active'));
            activeSubTabButton = subTabButtonToActivate;
            activeSubTabButton.classList.add('active');

            const contentId = activeSubTabButton.dataset.contentId;
            const loadGroup = activeSubTabButton.dataset.loadGroup;

            if (loadGroup && !loadedContentGroups.has(loadGroup)) {
                try {
                    console.log(`Loading content for group: ${loadGroup}, target content ID: ${contentId}`);
                    await loadContentGroup(loadGroup, contentId); // Pass contentId for initialization
                    loadedContentGroups.add(loadGroup);
                } catch (error) {
                    console.error(`Failed to load content for group ${loadGroup}:`, error);
                    let errorDisplay = document.getElementById(contentId);
                    if (!errorDisplay) {
                        errorDisplay = document.createElement('div');
                        errorDisplay.id = contentId;
                        errorDisplay.classList.add('tab-content');
                        mainContentArea.appendChild(errorDisplay);
                    }
                    errorDisplay.innerHTML = `<p>Error loading content for ${contentId}. Please check console.</p>`;
                }
            }

            mainContentArea.querySelectorAll('.tab-content').forEach(tc => {
                tc.classList.remove('active');
                tc.style.display = 'none';
            });

            const contentToShow = document.getElementById(contentId);
            if (contentToShow) {
                contentToShow.classList.add('active');
                contentToShow.style.display = 'block';
                 // If this is the chat completions tab, ensure its dynamic elements are (re)initialized
                if (contentId === 'tabChatCompletions' && typeof initializeChatCompletionsTab === "function") {
                    initializeChatCompletionsTab();
                }
            } else {
                console.warn(`Content ID "${contentId}" not found after attempting to load group "${loadGroup}".`);
                const placeholder = document.createElement('div');
                placeholder.id = contentId;
                placeholder.classList.add('tab-content', 'active');
                placeholder.style.display = 'block';
                placeholder.innerHTML = `<p>Content for ${contentId} is missing or failed to load.</p>`;
                const existingPlaceholder = mainContentArea.querySelector(`#${contentId}`);
                if (existingPlaceholder) existingPlaceholder.remove();
                mainContentArea.appendChild(placeholder);
            }
        }

        async function loadContentGroup(groupName, targetContentId) {
            const response = await fetch(`tabs/${groupName}_content.html`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} for tabs/${groupName}_content.html`);
            }
            const html = await response.text();
            mainContentArea.insertAdjacentHTML('beforeend', html);

            // After loading content, if it's the chat group and the specific tab, initialize
            if (groupName === 'chat' && targetContentId === 'tabChatCompletions') {
                if (typeof initializeChatCompletionsTab === "function") {
                     initializeChatCompletionsTab();
                } else {
                    console.warn("initializeChatCompletionsTab function not found after loading chat content.");
                }
            }
        }

        document.addEventListener('DOMContentLoaded', initTabs);

        // --- Chat Completions UI Specific Functions ---
        function escapeCurlData(data) {
            return data.replace(/'/g, "'\\''");
        }

        function addChatMessage(prefix, role = 'user', content = '') {
            const container = document.getElementById(prefix + '_messagesContainer');
            if (!container) {
                console.error("Messages container not found for prefix:", prefix);
                return;
            }
            const id = messageIdCounter[prefix]++;
            const entryDiv = document.createElement('div');
            entryDiv.className = 'message-entry';
            entryDiv.id = `${prefix}_message_entry_${id}`;
            entryDiv.innerHTML = `
                <label for="${prefix}_message_role_${id}">Role:</label>
                <select id="${prefix}_message_role_${id}" onchange="toggleToolFields('${prefix}', ${id})">
                    <option value="system" ${role === 'system' ? 'selected' : ''}>System</option>
                    <option value="user" ${role === 'user' ? 'selected' : ''}>User</option>
                    <option value="assistant" ${role === 'assistant' ? 'selected' : ''}>Assistant</option>
                    <option value="tool" ${role === 'tool' ? 'selected' : ''}>Tool</option>
                </select>
                <label for="${prefix}_message_content_${id}">Content:</label>
                <textarea id="${prefix}_message_content_${id}" rows="3">${content}</textarea>
                <label for="${prefix}_message_name_${id}">Name (Optional):</label>
                <input type="text" id="${prefix}_message_name_${id}" placeholder="Participant name">
                <div id="${prefix}_message_tool_fields_${id}" style="display: ${role === 'tool' ? 'block' : 'none'};">
                    <label for="${prefix}_message_tool_call_id_${id}">Tool Call ID (Required for tool role):</label>
                    <input type="text" id="${prefix}_message_tool_call_id_${id}">
                </div>
                <button class="remove-message-btn" onclick="removeChatMessage('${prefix}', ${id})">Remove</button>
            `;
            container.appendChild(entryDiv);
        }

        function toggleToolFields(prefix, id) {
            const roleSelect = document.getElementById(`${prefix}_message_role_${id}`);
            const toolFieldsDiv = document.getElementById(`${prefix}_message_tool_fields_${id}`);
            if (roleSelect && toolFieldsDiv) {
                toolFieldsDiv.style.display = roleSelect.value === 'tool' ? 'block' : 'none';
            }
        }

        function removeChatMessage(prefix, id) {
            const entryDiv = document.getElementById(`${prefix}_message_entry_${id}`);
            if (entryDiv) {
                entryDiv.remove();
            }
        }

        function buildPayloadFromForm(prefix) {
            const payload = {};
            const apiProviderEl = document.getElementById(prefix + '_api_provider');
            if (apiProviderEl) payload.api_provider = apiProviderEl.value || undefined;

            const modelEl = document.getElementById(prefix + '_model');
            if (modelEl) payload.model = modelEl.value || undefined;

            const messages = [];
            const messagesContainer = document.getElementById(prefix + '_messagesContainer');
            if (messagesContainer) {
                const messageEntries = messagesContainer.children;
                for (let i = 0; i < messageEntries.length; i++) {
                    const entryDiv = messageEntries[i];
                    if (!entryDiv.id || !entryDiv.id.startsWith(prefix + '_message_entry_')) continue;
                    const entryId = entryDiv.id.split('_').pop();

                    const roleEl = document.getElementById(`${prefix}_message_role_${entryId}`);
                    const contentEl = document.getElementById(`${prefix}_message_content_${entryId}`);
                    const nameEl = document.getElementById(`${prefix}_message_name_${entryId}`);
                    if (!roleEl || !contentEl) continue;

                    const role = roleEl.value;
                    const contentValue = contentEl.value;
                    const name = nameEl ? (nameEl.value || undefined) : undefined;

                    const message = { role, content: contentValue };
                    if (name) message.name = name;
                    if (role === 'tool') {
                        const toolCallIdEl = document.getElementById(`${prefix}_message_tool_call_id_${entryId}`);
                        message.tool_call_id = toolCallIdEl ? (toolCallIdEl.value || undefined) : undefined;
                        if (!message.tool_call_id) {
                            alert(`Tool Call ID is required for message ${i + 1} with role 'tool'.`);
                            throw new Error("Missing Tool Call ID for a tool message.");
                        }
                    }
                    messages.push(message);
                }
            }
            payload.messages = messages;

            const temperatureEl = document.getElementById(prefix + '_temperature');
            if (temperatureEl) {
                const tempVal = temperatureEl.value;
                if (tempVal !== "") payload.temperature = parseFloat(tempVal); else payload.temperature = undefined;
            }

            const maxTokensEl = document.getElementById(prefix + '_max_tokens');
            if (maxTokensEl) {
                 const maxTokensVal = maxTokensEl.value;
                if (maxTokensVal !== "") payload.max_tokens = parseInt(maxTokensVal); else payload.max_tokens = undefined;
            }

            const streamEl = document.getElementById(prefix + '_stream');
            if (streamEl) payload.stream = streamEl.checked;


            // Optional parameters
            const optionalFields = {
                top_p: { type: 'float', elIdSuffix: '_top_p' },
                frequency_penalty: { type: 'float', elIdSuffix: '_frequency_penalty' },
                presence_penalty: { type: 'float', elIdSuffix: '_presence_penalty' },
                minp: { type: 'float', elIdSuffix: '_minp', allowUndefined: true },
                topk: { type: 'int', elIdSuffix: '_topk', allowUndefined: true },
                seed: { type: 'int', elIdSuffix: '_seed', allowNull: true },
                stop: { type: 'json_or_csv_list', elIdSuffix: '_stop', allowNull: true },
                logprobs: { type: 'checkbox_to_null', elIdSuffix: '_logprobs', allowNull: true },
                top_logprobs: { type: 'int', elIdSuffix: '_top_logprobs', dependsOn: 'logprobs', allowUndefined: true },
                response_format: { type: 'select_object', elIdSuffix: '_response_format_type', key: 'type', allowNull: true },
                tools: { type: 'json', elIdSuffix: '_tools', allowNull: true },
                tool_choice: { type: 'json_or_string', elIdSuffix: '_tool_choice', allowUndefined: true, validStrings: ["auto", "none", "required"] },
                logit_bias: { type: 'json', elIdSuffix: '_logit_bias', allowNull: true },
                character_id: { type: 'string', elIdSuffix: '_character_id', allowUndefined: true },
                prompt_template_name: { type: 'string', elIdSuffix: '_prompt_template_name', allowUndefined: true }
            };

            for (const key in optionalFields) {
                const config = optionalFields[key];
                const el = document.getElementById(prefix + config.elIdSuffix);
                if (!el) continue;

                if (config.dependsOn && !document.getElementById(prefix + '_' + config.dependsOn)?.checked) {
                    payload[key] = config.allowNull ? null : (config.allowUndefined ? undefined : payload[key]);
                    continue;
                }

                let value;
                switch (config.type) {
                    case 'float': value = el.value !== "" ? parseFloat(el.value) : (config.allowUndefined ? undefined : (config.allowNull ? null : NaN)); break;
                    case 'int': value = el.value !== "" ? parseInt(el.value) : (config.allowUndefined ? undefined : (config.allowNull ? null : NaN)); break;
                    case 'string': value = el.value.trim() !== "" ? el.value.trim() : (config.allowUndefined ? undefined : (config.allowNull ? null : "")); break;
                    case 'checkbox_to_null': value = el.checked ? true : (config.allowNull ? null : false); break;
                    case 'json_or_csv_list':
                        if (el.value.trim() !== "") {
                            try { value = JSON.parse(el.value); }
                            catch (e) { value = el.value.split(',').map(s => s.trim()).filter(s => s); if(value.length === 0) value = config.allowNull ? null : (config.allowUndefined ? undefined : []);}
                        } else { value = config.allowNull ? null : (config.allowUndefined ? undefined : []); }
                        break;
                    case 'json':
                        if (el.value.trim() !== "") {
                            try { value = JSON.parse(el.value); }
                            catch (e) { alert(`Invalid JSON for ${key}`); throw new Error(`Invalid JSON for ${key}`); }
                        } else { value = config.allowNull ? null : (config.allowUndefined ? undefined : {}); }
                        break;
                    case 'select_object':
                        value = el.value ? { [config.key]: el.value } : (config.allowNull ? null : (config.allowUndefined ? undefined : {}));
                        break;
                    case 'json_or_string':
                        if (el.value.trim() !== "") {
                            if (config.validStrings && config.validStrings.includes(el.value.trim().toLowerCase())) {
                                value = el.value.trim().toLowerCase();
                            } else {
                                try { value = JSON.parse(el.value); }
                                catch (e) { alert(`Invalid value for ${key}. Must be one of ${config.validStrings.join(', ')} or a valid JSON object string.`); throw new Error(`Invalid value for ${key}`); }
                            }
                        } else { value = config.allowUndefined ? undefined : (config.allowNull ? null : "auto"); }
                        break;
                }
                if (value !== undefined && !(typeof value === 'number' && isNaN(value))) {
                    payload[key] = value;
                } else if (config.allowNull && value === null) {
                    payload[key] = null;
                } else if (config.allowUndefined) {
                    delete payload[key]; // Or payload[key] = undefined;
                }
            }
            // Final cleanup for undefined
            for (const key in payload) { if (payload[key] === undefined) { delete payload[key]; } }
            return payload;
        }

        function toggleRawJson(prefix) {
            const useRawJsonCheckbox = document.getElementById(prefix + '_useRawJson');
            if (!useRawJsonCheckbox) return;
            const useRawJson = useRawJsonCheckbox.checked;

            const formFieldsDiv = document.getElementById(prefix + '_formFields');
            const rawJsonContainerDiv = document.getElementById(prefix + '_rawJsonContainer');
            const rawPayloadTextarea = document.getElementById(prefix + '_payload_raw');

            if (formFieldsDiv) formFieldsDiv.style.display = useRawJson ? 'none' : 'block';
            if (rawJsonContainerDiv) rawJsonContainerDiv.style.display = useRawJson ? 'block' : 'none';

            if (useRawJson && rawPayloadTextarea) {
                try {
                    const currentPayload = buildPayloadFromForm(prefix);
                    rawPayloadTextarea.value = JSON.stringify(currentPayload, null, 2);
                } catch (e) {
                    console.warn("Could not build payload for raw view:", e.message);
                    rawPayloadTextarea.value = JSON.stringify({"error_building_payload": e.message, "tip": "Fix form errors or manually edit JSON."}, null, 2);
                }
            }
        }

        function generateChatCompletionsCurl() {
            const endpointId = 'createChatCompletion';
            const prefix = 'chatCompletions';
            const curlEl = document.getElementById(endpointId + '_curl');
            if (!curlEl) return;

            const token = document.getElementById('apiKeyInput').value || "YOUR_API_TOKEN_PLACEHOLDER";
            const baseUrl = document.getElementById('baseUrl').value;
            let payload;

            const useRawJsonCheckbox = document.getElementById(prefix + '_useRawJson');
            if (!useRawJsonCheckbox) { curlEl.textContent = "Error: Raw JSON toggle checkbox not found."; return; }
            const useRawJson = useRawJsonCheckbox.checked;

            if (useRawJson) {
                const rawPayloadEl = document.getElementById(prefix + '_payload_raw');
                if (rawPayloadEl && rawPayloadEl.value.trim() !== "") {
                     try { payload = JSON.parse(rawPayloadEl.value); }
                     catch(e) { curlEl.textContent = "Error: Invalid Raw JSON for cURL generation."; return; }
                } else {
                     curlEl.textContent = "Error: Raw JSON payload for cURL is empty."; return;
                }
            } else {
                try {
                    payload = buildPayloadFromForm(prefix);
                } catch (e) {
                     curlEl.textContent = "Error building payload from form for cURL: " + e.message;
                     return;
                }
            }

            const curlCommand = `curl -X POST "${baseUrl}/api/v1/chat/completions" \\
-H "accept: application/json" \\
-H "Content-Type: application/json" \\
-H "Token: ${token.replace(/"/g, '\\"')}" \\
-d '${escapeCurlData(JSON.stringify(payload, null, 2))}'`;
            curlEl.textContent = curlCommand;
        }

        async function handleChatCompletionsRequest() {
            const endpointId = 'createChatCompletion';
            const prefix = 'chatCompletions';
            const responseArea = document.getElementById(endpointId + '_response');
            if (!responseArea) { console.error("Response area not found!"); return; }

            responseArea.textContent = 'Sending...';
            generateChatCompletionsCurl();

            let payload;
            const useRawJsonCheckbox = document.getElementById(prefix + '_useRawJson');
            if (!useRawJsonCheckbox) { responseArea.textContent = "Error: Raw JSON toggle checkbox not found."; return; }
            const useRawJson = useRawJsonCheckbox.checked;

            const baseUrl = document.getElementById('baseUrl').value;
            const token = document.getElementById('apiKeyInput').value;

            if (useRawJson) {
                const rawPayloadEl = document.getElementById(prefix + '_payload_raw');
                if (!rawPayloadEl) { responseArea.textContent = "Error: Raw JSON textarea not found."; return; }
                try {
                    payload = JSON.parse(rawPayloadEl.value);
                } catch (e) {
                    responseArea.textContent = "Error: Invalid Raw JSON Payload.\n" + e.message;
                    return;
                }
            } else {
                 try {
                    payload = buildPayloadFromForm(prefix);
                } catch (e) {
                    responseArea.textContent = "Error building payload from form: " + e.message;
                    return;
                }
            }

            const isStreaming = payload.stream;
            if (isStreaming) {
                responseArea.textContent = '';
            }

            try {
                const fetchResponse = await fetch(`${baseUrl}/api/v1/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json, text/event-stream', // Accept both
                        'Token': token
                    },
                    body: JSON.stringify(payload)
                });

                if (!fetchResponse.ok) {
                    const errorData = await fetchResponse.json().catch(() => ({ detail: fetchResponse.statusText, status: fetchResponse.status }));
                    throw new Error(`HTTP error ${fetchResponse.status}: ${JSON.stringify(errorData.detail || errorData)}`);
                }

                const contentType = fetchResponse.headers.get("content-type");
                if (isStreaming && contentType && contentType.includes("text/event-stream") && fetchResponse.body) {
                    const reader = fetchResponse.body.getReader();
                    const decoder = new TextDecoder();
                    let doneReading = false;
                    let currentBuffer = "";
                    let streamHadContent = false;

                    while (!doneReading) {
                        const { value, done } = await reader.read();
                        doneReading = done;
                        currentBuffer += decoder.decode(value, { stream: !doneReading });

                        let eventEndIndex;
                        while ((eventEndIndex = currentBuffer.indexOf('\n\n')) >= 0) {
                            const eventString = currentBuffer.substring(0, eventEndIndex);
                            currentBuffer = currentBuffer.substring(eventEndIndex + 2);

                            if (eventString.startsWith('data: ')) {
                                streamHadContent = true;
                                const dataStr = eventString.substring(6).trim();
                                if (dataStr === '[DONE]') {
                                    responseArea.textContent += "\nStream finished by [DONE] signal.\n";
                                    doneReading = true; break;
                                }
                                try {
                                    const dataJson = JSON.parse(dataStr);
                                    const contentChunk = dataJson.choices?.[0]?.delta?.content;
                                    if (contentChunk) {
                                        responseArea.textContent += contentChunk;
                                    } else if (dataJson.choices?.[0]?.finish_reason) {
                                         responseArea.textContent += `\n[Finish Reason: ${dataJson.choices[0].finish_reason}]\n`;
                                    } else if (Object.keys(dataJson).length > 0) {
                                         responseArea.textContent += `\n(Stream JSON: ${dataStr})\n`;
                                    }
                                } catch (e) {
                                    if (dataStr) {
                                        console.warn('Non-JSON stream data or parse error:', dataStr, e);
                                        responseArea.textContent += `\n(Stream data: ${dataStr})\n`;
                                    }
                                }
                            } else if (eventString.trim()) { // Non-data line, could be a comment or empty event
                                console.log("Received non-data line in stream:", eventString);
                            }
                             responseArea.scrollTop = responseArea.scrollHeight;
                        }
                         if (doneReading) break; // Break outer while if [DONE] was processed
                    }
                    if (currentBuffer.trim()) {
                         if (currentBuffer.startsWith('data: ')) {
                             responseArea.textContent += `\n(Final unprocessed stream data: ${currentBuffer.substring(6).trim()})\n`;
                         } else if (currentBuffer.trim()){
                              responseArea.textContent += `\n(Final unprocessed stream buffer: ${currentBuffer.trim()})\n`;
                         }
                    }
                    if (!responseArea.textContent.includes("[DONE]") && !responseArea.textContent.includes("Stream finished")) {
                        responseArea.textContent += streamHadContent ? "\nStream ended.\n" : "Stream connected, but no data or [DONE] signal received.\n";
                    }
                } else { // Non-streaming or non-event-stream response
                    const responseData = await fetchResponse.json();
                    responseArea.textContent = JSON.stringify(responseData, null, 2);
                }
            } catch (error) {
                console.error('Error during chat completion:', error);
                responseArea.textContent = 'Error: ' + error.message;
            }
        }

        function initializeChatCompletionsTab() {
            const prefix = 'chatCompletions';
            console.log("Initializing Chat Completions Tab");
            const container = document.getElementById(prefix + '_messagesContainer');
            if (container) {
                container.innerHTML = ''; // Clear existing messages
                 messageIdCounter[prefix] = 0; // Reset counter

                addChatMessage(prefix, 'system', 'You are a helpful assistant.');
                addChatMessage(prefix, 'user', 'Hello! Can you tell me a joke?');
            } else {
                console.warn("Messages container not found during chat completions tab initialization.");
            }


            const useRawJsonCheckbox = document.getElementById(prefix + '_useRawJson');
            if (useRawJsonCheckbox) {
                 if (useRawJsonCheckbox.checked) {
                    toggleRawJson(prefix);
                } else {
                    try {
                        const initialPayload = buildPayloadFromForm(prefix);
                        const rawPayloadTextarea = document.getElementById(prefix + '_payload_raw');
                        if(rawPayloadTextarea) rawPayloadTextarea.value = JSON.stringify(initialPayload, null, 2);
                    } catch(e) { console.warn("Initial raw payload build failed for chat completions:", e.message); }
                }
            } else {
                console.warn("Raw JSON toggle not found during chat completions tab init.");
            }
            generateChatCompletionsCurl();
        }

        // Generic makeRequest (if needed for other tabs, can be adapted)
        // For now, handleChatCompletionsRequest is specific.
        // If you have the `makeRequest` function from your original HTML, you can keep it for other tabs,
        // but the `handleChatCompletionsRequest` is now tailored for the new chat form.

    </script>
</body>
</html>