Key Points about These Tests:

    Unit Tests (test_sqlite_db.py): Thoroughly test the database library's methods in isolation using :memory: databases. Cover core operations, sync log generation, versioning, and error conditions.

    Component Tests (test_sync_client.py, test_sync_server.py):

        Test the logic of the ClientSyncEngine and ServerSyncProcessor classes.

        Use real Database instances (:memory:) to test the database interaction part of the sync logic.

        Mock network calls (requests.post/get) for the client tests.

        Test state management, idempotency, basic change application, and LWW conflict resolution.

        Server tests verify that the server applies changes correctly using its authoritative timestamp and originating client ID.

    @pytest.mark.asyncio: Required for testing async def functions used in the ServerSyncProcessor.

    Fixtures: Heavy use of pytest fixtures simplifies setup and teardown of database instances and state files.

    Helpers: Functions like get_log_count, get_entity_version, create_mock_log_entry, get_entity_state reduce repetition in tests.

    Integration Tests (Placeholder): The structure includes comments on how to approach integration tests using FastAPI's TestClient and httpx. These are crucial for verifying the end-to-end flow but require more setup (especially mocking the get_db_for_user dependency correctly within the test context).

    # --- TODO: Add Integration Tests ---
# These would involve:
# 1. Setting up a TestClient for the FastAPI app (using httpx).
# 2. Setting up separate DB instances for client and server (using fixtures).
# 3. Instantiating ClientSyncEngine.
# 4. Making calls from ClientSyncEngine to the TestClient endpoints.
# 5. Asserting the state of *both* databases after sync cycles.
# Example sketch:
# from fastapi.testclient import TestClient
# from main import app # Assuming your FastAPI app instance is in main.py

# @pytest.fixture
# def api_client():
#     return TestClient(app)

# def test_integration_simple_create_sync(memory_db_factory, api_client):
#     client_db = memory_db_factory("integ_client")
#     # Mock get_db_for_user to return a specific test DB for the server
#     # ... complex mocking setup ...
#     engine = ClientSyncEngine(client_db, api_client.base_url, "integ_client", "state.json")
#     client_db.add_keyword("integ_test")
#     engine.run_sync_cycle() # Push
#     # Assert server state (via API or direct DB access in test)
#     engine.run_sync_cycle() # Pull (should be empty if server filters echo)
#     # Assert client state